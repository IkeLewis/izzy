(define-module (izzy input-event)
  #:export (<input-event> input-event->list<kernel-input-event> modifiers non-modifier)
  #:use-module (izzy key)
  #:use-module (oop goops)
  #:use-module (srfi srfi-1)
  #:use-module (izzy hid-constants)
  #:use-module (izzy log)
  #:use-module (izzy timeval)
  #:use-module (izzy kernel-input-event)
  #:use-module (izzy input-event))

(define-class <input-event> ()
  (modifiers #:init-value '() #:accessor modifiers)
  (non-modifier #:init-value #f #:accessor non-modifier))

(define-method (initialize (obj <input-event>) initargs)
  ;; (unless (every (lambda (x) (member allowed-modifiers))
  ;; 		 (drop-right initargs 1))
  ;;   (error "Invalid argument; all but the last argument must be modifiers"))
  ;; (unless (and (is-a? (last initargs) <key>)
  ;; 	       (not (modifier-flag (last initargs))))
  ;;   (error "The last argument must be a non-modifier"))
  (unless (<= (length initargs) 2)
    (error "Too many args"))
  
  (when (= (length initargs) 1)
    (set! initargs (cons '() initargs)))
  
  (let ((to-kie (lambda (ia)
		  (cond ((is-a? ia <integer>)
			 (make <kernel-input-event> ev-key ia key-press))
			((is-a? ia <kernel-input-event>)
			 ia)
			(else
			 (error "Invalid type"))))))
    (slot-set! obj 'modifiers (map to-kie (first initargs)))
    (slot-set! obj 'non-modifier (to-kie (second initargs)))))

(define-method (input-event->list<kernel-input-event> (obj <input-event>))
  (let* ((presses (append (modifiers obj) (list (non-modifier obj))))
	 (releases (map deep-clone presses))
	 
	 (next-time (let* ((time-between-input-events (make <timeval> 0 30000))
			   (end-time (make <timeval>))
			   (cur-time (- end-time
					(* time-between-input-events (* 2 (length presses))))))
		      (lambda ()
			(set! cur-time (+ cur-time time-between-input-events))
			cur-time))))
    (append (map (lambda (kie)
		   (slot-set! kie 'time (next-time))
		   (slot-set! kie 'value key-press)
		   kie) presses)
	    (map (lambda (kie)
		   (slot-set! kie 'time (next-time))
		   (slot-set! kie 'value key-release)
		   kie) (reverse releases)))))

(define-method (display (ie <input-event>) . args)
  (set! args (append args (list #t)))
  (logln (second args)
		 "(modifiers:~a\nnon-modifier:~a)\n"
		 (modifiers ie)
		 (non-modifier ie)))
